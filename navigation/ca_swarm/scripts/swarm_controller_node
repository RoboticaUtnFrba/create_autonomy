#! /usr/bin/env python

from collections import namedtuple
import numpy as np

import rospy
import tf2_ros

from tf import transformations

from geometry_msgs.msg import Twist
from nav_msgs.msg import Odometry

class SwarmRobotProxy(object):

    def __init__(self, name, frame, cmd_vel, b_T_i):
        self.name = name
        self.frame = frame
        self.cmd_vel = cmd_vel
        self.b_T_i = b_T_i

class SwarmControllerNode(object):

    def __init__(self):
        rospy.init_node('swarm_controller')
        robot_frame_suffix = rospy.get_param(
            '~robot_frame_suffix', '_tf/base_link'
        )
        self._swarm_robots = [
            SwarmRobotProxy(
                name=robot_name,
                frame=robot_name + robot_frame_suffix,
                cmd_vel=rospy.Publisher(
                    robot_name + '/cmd_vel', Twist, queue_size=10
                ),
                b_T_i=transformations.identity_matrix()
            ) for robot_name in rospy.get_param('~swarm_robots')
        ]

        self._box_v = 0.
        self._box_w = 0.
        rospy.Subscriber("/unit_box/odom", Odometry, self.box_odometry)

        self._v0 = 0.
        self._w0 = 0.

        self._tf_buffer = tf2_ros.Buffer()
        self._tf_listener = tf2_ros.TransformListener(self._tf_buffer)
        self._body_frame = rospy.get_param('~body_frame')

        self._swarm_cmd_vel_sub = rospy.Subscriber(
            'cmd_vel', Twist, self._on_swarm_cmd_vel
        )

        self._dt = 0.1
        rospy.Timer(rospy.Duration(self._dt), self.timer_cb) # 20 Hz

    def timer_cb(self, event):
      self.run()
    
    def _on_swarm_cmd_vel(self, swarm_twist):
        self._v0 = swarm_twist.linear.x
        self._w0 = swarm_twist.angular.z
    
    def box_odometry(self, msg):
        self._box_v = msg.twist.twist.linear.x
        self._box_w = msg.twist.twist.angular.z

    def spin(self):
        rospy.spin()
    
    def run(self):
      R_desired = 2

      v = min(max(self._v0, R_desired * self._w0), 0.3)
      w = min(v/R_desired, self._w0)

      R = v / w if w != 0. else np.inf

      self._box_error_v = v - self._box_v
      self._box_error_w = w - self._box_w

      for robot in self._swarm_robots:
          robot_twist = Twist()
          try:
              robot_transform_in_body_frame = self._tf_buffer.lookup_transform(
                  self._body_frame, robot.frame, rospy.Time()
              ).transform

              x = robot_transform_in_body_frame.translation.x
              y = robot_transform_in_body_frame.translation.y
              _, _, yaw = transformations.euler_from_quaternion([
                  robot_transform_in_body_frame.rotation.x,
                  robot_transform_in_body_frame.rotation.y,
                  robot_transform_in_body_frame.rotation.z,
                  robot_transform_in_body_frame.rotation.w
              ])

              v_box = 0.
              w_box = 0.

              if np.allclose(robot.b_T_i, np.identity(4, dtype=np.float64)):
                robot.b_T_i = transformations.compose_matrix(angles=[0., 0., yaw], translate=[x, y, 0.])
              else:
                b_T_c = transformations.compose_matrix(angles=[0, 0, yaw], translate=[x, y, 0])
                
                K = 0.65
                box_mass = 1 # kg

                dv = self._box_error_v if R == np.inf else self._box_error_w * (R - y)
                i_T_tau = transformations.compose_matrix(translate=[max(0, dv * box_mass / K), 0., 0])
                
                c_T_tau = transformations.concatenate_matrices(
                  transformations.inverse_matrix(b_T_c),
                  robot.b_T_i,
                  i_T_tau
                )

                # https://globaljournals.org/GJRE_Volume14/1-Kinematics-Localization-and-Control.pdf
                [xd, yd, _] = transformations.translation_from_matrix(c_T_tau)
                [_, _, beta] = transformations.euler_from_matrix(c_T_tau)
                
                rho = np.linalg.norm([xd, yd])
                theta = np.arctan2(yd, xd)

                K_theta = 1.0
                K_rho = 1.2
                K_alpha = 0.5

                v_box = K_rho * rho * np.cos(theta)
                w_box = K_theta * theta * rho + K_alpha * beta

              # Send velocities to the robots
              robot_twist.linear.x = v_box
              robot_twist.angular.z = w_box

          except (tf2_ros.LookupException,
                  tf2_ros.ConnectivityException,
                  tf2_ros.ExtrapolationException) as e:
              rospy.logwarn(
                  'cannot lookup transform from %s to %s: %s',
                  robot.frame, self._body_frame, str(e)
              )
              continue
          
          robot.cmd_vel.publish(robot_twist)


def main():
    node = SwarmControllerNode()
    try:
        node.spin()
    except rospy.ROSInterruptException:
        pass


if __name__ == '__main__':
    main()
